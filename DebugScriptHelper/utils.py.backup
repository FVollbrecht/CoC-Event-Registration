#!/usr/bin/env python3

import pickle
import os
import logging
import asyncio
import threading
from datetime import datetime
import discord
from discord import Embed

# Discord log channel handler
discord_log_channel = None

# Erstelle einen benutzerdefinierten Log-Handler f√ºr Discord
class DiscordLogHandler(logging.Handler):
    def __init__(self):
        logging.Handler.__init__(self)
        self.log_messages = []
        self.log_lock = threading.Lock()

    def emit(self, record):
        # Formatiere die Log-Nachricht
        msg = self.format(record)
        # F√ºge sie der Liste hinzu (Thread-sicher)
        with self.log_lock:
            self.log_messages.append((record.levelname, msg))
    
    def get_logs(self, max_count=5):
        with self.log_lock:
            # Kopiere bis zu max_count Nachrichten aus der Liste
            result = self.log_messages[:max_count]
            # Entferne die kopierten Nachrichten aus der Liste
            self.log_messages = self.log_messages[len(result):]
            return result

# Erstelle einen globalen Handler, der sp√§ter initialisiert wird
discord_handler = DiscordLogHandler()
discord_handler.setLevel(logging.INFO)
discord_handler.setFormatter(logging.Formatter('%(message)s'))

# Setup logging
# Sicherstellen, dass die Datei existiert und beschreibbar ist
try:
    with open("discord_bot.log", "a") as f:
        f.write(f"--- Log Start: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ---\n")
except Exception as e:
    print(f"Fehler beim Zugriff auf Log-Datei: {e}")

# Konfiguriere das Root-Logger f√ºr alle Module
root_logger = logging.getLogger()
root_logger.setLevel(logging.INFO)

# Formatierung f√ºr alle Log-Handler
log_format = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Handler f√ºr Konsole
console_handler = logging.StreamHandler()
console_handler.setFormatter(log_format)
root_logger.addHandler(console_handler)

# Handler f√ºr Datei
try:
    file_handler = logging.FileHandler("discord_bot.log", mode='a')
    file_handler.setFormatter(log_format)
    root_logger.addHandler(file_handler)
except Exception as e:
    print(f"Fehler beim Erstellen des File-Handlers: {e}")

# F√ºge den Discord-Handler zum Root-Logger hinzu
discord_handler.setFormatter(log_format)
root_logger.addHandler(discord_handler)

# Erstelle den event_bot-Logger als Kind des Root-Loggers
logger = logging.getLogger("event_bot")
logger.info("Logger initialisiert")

async def send_to_log_channel(message, level="INFO", guild=None):
    """
    Sendet eine Nachricht an den Log-Kanal
    
    Parameters:
    - message: Die zu sendende Nachricht
    - level: Der Log-Level (INFO, WARNING, ERROR, etc.)
    - guild: Die Guild, in der der Log-Kanal gesucht werden soll (optional)
    
    Returns:
    - True bei Erfolg, False bei Fehler
    """
    from config import LOG_CHANNEL_NAME, LOG_CHANNEL_ID
    global discord_log_channel
    
    # Log zuerst in die normale Logdatei
    if level == "INFO":
        logger.info(message)
    elif level == "WARNING":
        logger.warning(message)
    elif level == "ERROR":
        logger.error(message)
    elif level == "CRITICAL":
        logger.critical(message)
    else:
        logger.info(message)
    
    try:
        bot = get_bot()
        if not bot:
            return False
        
        # Wenn der Log-Kanal noch nicht gefunden wurde, versuche ihn zu finden
        if not discord_log_channel and (guild or LOG_CHANNEL_ID):
            if LOG_CHANNEL_ID:
                # Versuche, den Kanal √ºber die ID zu finden
                discord_log_channel = bot.get_channel(LOG_CHANNEL_ID)
            elif guild:
                # Suche im angegebenen Guild nach dem Kanal
                discord_log_channel = discord.utils.get(guild.text_channels, name=LOG_CHANNEL_NAME)
        
        # Versuche, die Nachricht zu senden, wenn der Kanal verf√ºgbar ist
        if discord_log_channel:
            # Formatiere die Nachricht je nach Log-Level
            if level == "INFO":
                formatted_message = f"‚ÑπÔ∏è **INFO**: {message}"
            elif level == "WARNING":
                formatted_message = f"‚ö†Ô∏è **WARNUNG**: {message}"
            elif level == "ERROR":
                formatted_message = f"‚ùå **FEHLER**: {message}"
            elif level == "CRITICAL":
                formatted_message = f"üö® **KRITISCH**: {message}"
            else:
                formatted_message = f"‚ÑπÔ∏è {message}"
            
            await discord_log_channel.send(formatted_message)
            return True
    except Exception as e:
        logger.error(f"Fehler beim Senden der Nachricht an den Log-Kanal: {e}")
    
    return False

def get_bot():
    """
    Hilfsfunktion, um eine Referenz auf das Bot-Objekt zu bekommen
    """
    try:
        import sys
        import bot
        return bot.bot if hasattr(bot, 'bot') else None
    except (ImportError, AttributeError) as e:
        logger.error(f"Kann Bot-Objekt nicht abrufen: {e}")
        return None

# Constants
SAVE_FILE = "event_data.pkl"

def load_data():
    """Load event data from pickle file"""
    try:
        if os.path.exists(SAVE_FILE):
            with open(SAVE_FILE, 'rb') as f:
                data = pickle.load(f)
                logger.info(f"Data loaded from {SAVE_FILE}")
                return data.get('event_data', {}), data.get('channel_id'), data.get('user_team_assignments', {})
        else:
            logger.info("No save file found, starting with empty data")
            return {}, None, {}
    except Exception as e:
        logger.error(f"Error loading data: {e}")
        return {}, None, {}

def save_data(event_data, channel_id, user_team_assignments):
    """Save event data to pickle file"""
    try:
        data = {
            'event_data': event_data,
            'channel_id': channel_id,
            'user_team_assignments': user_team_assignments
        }
        with open(SAVE_FILE, 'wb') as f:
            pickle.dump(data, f)
        logger.info(f"Data saved to {SAVE_FILE}")
        return True
    except Exception as e:
        logger.error(f"Error saving data: {e}")
        return False

def has_role(user, role_name):
    """Check if a user has a specific role or is in the ADMIN_IDS list
    
    Parameters:
    - user: Discord user or member object
    - role_name: The role name to check for
    
    Returns:
    - True if user has the role or is in ADMIN_IDS
    - False otherwise
    """
    from config import ADMIN_IDS
    
    try:
        # Wenn der Benutzer in ADMIN_IDS ist, immer True zur√ºckgeben
        if hasattr(user, 'id') and str(user.id) in ADMIN_IDS:
            return True
            
        # Bei DMs ist user ein User-Objekt und kein Member-Objekt
        if not hasattr(user, 'roles'):
            # In DMs erlauben wir keine Rollenpr√ºfung, au√üer f√ºr Admins (oben gepr√ºft)
            return False
            
        # Normale Rollenpr√ºfung f√ºr Server-Kontexte
        return any(role.name == role_name for role in user.roles)
    except Exception as e:
        logger.error(f"Error checking roles: {e}")
        return False

def parse_date(date_str):
    """Parse date string in format DD.MM.YYYY"""
    try:
        return datetime.strptime(date_str, "%d.%m.%Y")
    except ValueError:
        return None

def format_event_details(event):
    """Format event details as Discord embed"""
    if not event:
        return "Kein aktives Event."
    
    # Pr√ºfen, ob es ein echtes Event mit Inhalt ist
    if not event.get('name') or not event.get('date'):
        return "Kein aktives Event."
        
    embed = Embed(
        title=f"üìÖ Event: {event['name']}",
        description=event.get('description', 'Keine Beschreibung verf√ºgbar'),
        color=discord.Color.blue()
    )
    
    # Add event details
    embed.add_field(name="üìÜ Datum", value=event['date'], inline=True)
    embed.add_field(name="‚è∞ Uhrzeit", value=event['time'], inline=True)
    embed.add_field(name="\u200b", value="\u200b", inline=True)  # Spacer for alignment
    
    # Add team registration info
    embed.add_field(
        name="üë• Team-Anmeldungen",
        value=f"{event['slots_used']}/{event['max_slots']} Pl√§tze belegt",
        inline=True
    )
    embed.add_field(
        name="üî¢ Max. Teamgr√∂√üe",
        value=str(event['max_team_size']),
        inline=True
    )
    embed.add_field(name="\u200b", value="\u200b", inline=True)  # Spacer for alignment
    
    # Add registered teams
    teams_text = ""
    if event['teams']:
        for team_name, size in event['teams'].items():
            teams_text += f"‚Ä¢ **{team_name}**: {size} {'Person' if size == 1 else 'Personen'}\n"
    else:
        teams_text = "Noch keine Teams angemeldet."
    
    embed.add_field(
        name=f"üìã Angemeldete Teams ({len(event['teams'])})",
        value=teams_text or "Keine Teams angemeldet",
        inline=False
    )
    
    # Add waitlist if exists
    if event['waitlist']:
        waitlist_text = ""
        for i, (team_name, size) in enumerate(event['waitlist']):
            waitlist_text += f"{i+1}. **{team_name}**: {size} {'Person' if size == 1 else 'Personen'}\n"
        
        embed.add_field(
            name=f"‚è≥ Warteliste ({len(event['waitlist'])})",
            value=waitlist_text,
            inline=False
        )
    
    # Add footer with instructions
    embed.set_footer(text="Verwende /reg um dein Team anzumelden oder /wl f√ºr die Warteliste.")
    
    return embed

def format_event_list(event):
    """Format event as plain text (fallback)"""
    if not event:
        return "Kein aktives Event."
    
    text = f"**üìÖ Event: {event['name']}**\n"
    text += f"üìÜ Datum: {event['date']}\n"
    text += f"‚è∞ Uhrzeit: {event['time']}\n"
    text += f"üìù Beschreibung: {event['description']}\n\n"
    
    text += f"üë• Team-Anmeldungen: {event['slots_used']}/{event['max_slots']} Pl√§tze belegt\n"
    text += f"üî¢ Max. Teamgr√∂√üe: {event['max_team_size']}\n\n"
    
    text += f"üìã Angemeldete Teams ({len(event['teams'])}):\n"
    if event['teams']:
        for team_name, size in event['teams'].items():
            text += f"‚Ä¢ {team_name}: {size} {'Person' if size == 1 else 'Personen'}\n"
    else:
        text += "Noch keine Teams angemeldet.\n"
    
    if event['waitlist']:
        text += f"\n‚è≥ Warteliste ({len(event['waitlist'])}):\n"
        for i, (team_name, size) in enumerate(event['waitlist']):
            text += f"{i+1}. {team_name}: {size} {'Person' if size == 1 else 'Personen'}\n"
    
    return text